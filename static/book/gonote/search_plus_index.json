{"./":{"url":"./","title":"Introduction","keywords":"","body":"介绍 Golang学习笔记 Copyright© Landers all right reserved，powered by Landers1037更新于 2019-07-01 "},"gonote1.html":{"url":"gonote1.html","title":"变量","keywords":"","body":"Golang学习笔记 golang的变量 对于go静态语言，其中的变量定义类似于c语言的变量定义，但是提供更多的变量类型 var num int num = 10 var num1 int = 10 //使用关键字var构建变量，等效于使用符号:= num2 := 12 多重变量赋值 //go天生支持多变量的赋值 i ,j = j ,i //直接交换两个值，而不需要中间变量 var i ,j int = 2 ,3 匿名变量 golang可以一次返回多值，但是有时候有些变量的值不需要，使用匿名变量解决 func main()(name,age){ name := 'pig' age := 10 } name,_ = main() //使用占位符_就可以产生匿名变量 golang的常量 //使用const关键字定义 const pi float64 = 3.1415926 与变量不同的是，常量是不变的，也不可以对其进行修改，常量的赋值同样支持多值 const a,b int = 0,3 当不指定类型如int的时候，默认就是无类型常量 常量的赋值是在代码的编译期间，而不是运行期间，所以如果等号右边是函数是在运行的时候才能返回值的时候，就不会编译通过 布尔型 //go的原生支持true,false,iota iota类似一个标记，每当遇到const赋值的时候就自动置0，然后每次常量赋值自动加1 var v bool v = true v2 := (1==2) //后面的推导式运算得到结果false，所以赋值给v2 整型 //整型有许多的分类int，int8，int32等 v := int32 2 注意：不同的int型不能相互赋值，需要使用强制转换 var v1 = int8 2 var v2 = int32 20 v1 = in8(v2) 注意：不同的int型不能相互比较 浮点数 var f1 = float32 2.0 //注意不加小数点就默认是int型 var f2 = float64 12.0 默认新建float型的时候为float64 注意：不同float型不能相互赋值，需要强制转换 浮点数的比较 //因为浮点数的生成不是精确值，所以不能直接使用==比较 //可以使用相对误差来比较 math.Fdim(f1,f2,dex) //dex为误差，小于则判断相等 复数 v1 := 1+3j v2 := complex(1,3) //二者结果相同 字符串 字符串实质是个不能改变值的数组 s := \"hello\" str = s[0] //取第一个字母 字符串连接 \"hello\" + \"world\" 字符串长度 len(s) 对字符串遍历 //与python的range函数类似，go的返回两个值，下标和下标对应的数据 for i ,s := range(str){ printf() } // n = len(str) for i:=0;i 默认打印出来的是字符对应的Unicode编码 数组 [32]byte //32位的元素为byte的数组 [1000] *float //元素为指针的数组 [3][5] int //二维数组 //与python类似使用下标访问内部元素 arr[i] 可以使用range对数组遍历 i,num := range(arr) Copyright© Landers all right reserved，powered by Landers1037更新于 2019-06-01 "},"gonote2.html":{"url":"gonote2.html","title":"数组","keywords":"","body":"Go学习笔记2 数组切片 在go中数组在生成后，对数组的赋值，或者将数组作为参数传递并进行值的修改时，都会对数组创建一个副本，最后产生变化的都是新生成的副本数组而原数组的值不能被改变。 package main import ( \"fmt\" ) func modify(array [5]int){ array[0] = 10 fmt.Println(\"in modify array value is\" , array) } func main(){ array := [5]int{1,2,3,4,5} modify(array) fmt.Println(\"in main array value is\" , array) } 为方便修改数组，引入了数组切片的概念 数组切片类似一个指针，指向原数组，包含一段存储空间和数组的元素个数 //可以基于原数组创建切片也可以直接创建 func main(){ var myArray [10]int = [10]int {1,2,3,4,5,6,7,8,9,10} var mySlice []int = myArray[:5] fmt.Println(\"elements of myArray\") for _,v := range myArray{ fmt.Println(v) } fmt.Println(\"\\n elements of mySlice\") for _,v := range mySlice{ fmt.Println(v) } } //切片包含全部元素 var mySlice []int = myArray[:] //包含后五个元素 var mySlice []int = myArray[5:] //直接创建切片 mySlice1 := make([]int 5) //元素为5，初始为0 mySlice2 := make([]int 5,10) //元素为5，预留10个存储空间 mySlice3 := []int {1,2,3,4,5} //直接创建并初始化 切片的优点，可以动态改变内部元素的长度，因为有存储空间，使用cap()返回切片的存储空间 func main() { //直接创建切片 mySlice1 := make([]int,5) //元素为5，初始为0 mySlice2 := make([]int ,5,10) //元素为5，预留10个存储空间 //mySlice3 := []int {1,2,3,4,5} //直接创建并初始化 fmt.Println(\"len\",len(mySlice1)) fmt.Println(\"cap\",cap(mySlice2)) } 切片支持使用append动态扩展 mySlice = append(mySlice ,1,2,3) mySlice2 := []int{1,2,3} mySlice = append(mySlice,mySlice2...) //...用于将mySlice切片的全部元素拆分后加入 基于数组切片创建切片 old := []int{1,2,3,4,5} new := old[:3] // 新的切片长度可以比旧的大，多出的元素全部为0 内容复制 //按照较小的数组进行复制 slice1 := []int{1,2,3,4,5} slice2 := []int{5,6,7} copy(slice2,slice1) //复制slice1的前三个到2中 copy(slice1,slice2) //复制slice2的3个到1中前三个位置 Copyright© Landers all right reserved，powered by Landers1037更新于 2019-06-01 "},"gonote3.html":{"url":"gonote3.html","title":"字典","keywords":"","body":"Go学习笔记3 map字典 创建一个结构体类型存储数据，放到字典内 package main import \"fmt\" type Personinfo struct { id string name string age string } func main(){ var persondb map[string] Personinfo persondb = make(map[string] Personinfo) persondb[\"1\"] = Personinfo{\"2016001\",\"joy\",\"15\"} persondb[\"2\"] = Personinfo{\"2016002\",\"bob\",\"55\"} person,ok := persondb[\"1\"] if ok{ fmt.Println(\"1234 data is\",person.name) } else{ fmt.Println(\"not found 1234\") } } 注意：go的if else语句，else要紧跟在if判断条件的后面不能换行 map的声明如下，也可以使用make函数创建 map [键的类型] 值的类型 mymap = make(map[string] Personinfo) mymap = make(map[string] Personinfo ,100) 指定分配的空间大小 创建并初始化 mymap := map[string] Personinfo{ \"1234\": Personinfo{ \"2016003\",\"pig\",\"5\"}, //注意这个}不能换行，换行就错了 } 删除其中的键值 delete(mymap,\"1234\") 删除的时候，如果没有这个键不会发生任何事，如果传入的mymap为空，会发生异常 使用range可以对map遍历，返回值是键 for data := range mymap{ println(data) //打印出来的是键 println(mymap[data].name) } 直接使用键访问数据，返回键的值和一个bool值表示该键是否存在 person,ok := persondb[\"1\"] Copyright© Landers all right reserved，powered by Landers1037更新于 2019-06-01 "},"gonote4.html":{"url":"gonote4.html","title":"流程控制","keywords":"","body":"Go学习笔记4 流程控制 条件语句 func main(){ a := 5 if a=5\") } } 在有返回值的函数里，有return的语句不能写在if else的判断块内，否则会找不到返回值 选择语句 func main() { var i int = 2 switch i { case 1: fmt.Println(\"out is 1\") case 2: fmt.Println(\"out is 2\") } } 在switch后面甚至不需要写表达式，直接把判断条件放在case的后面即可 在case中添加fallthrough后，会紧接着执行下一个case 不设定switch的条件表达式，此时的switch语句与if else语句的逻辑一致 循环语句 sum := 0 for i:=0;i 在go中没有while和do while语句，考虑无限循环的情况如下写法 for { sum++ if sum >100{ break } } for的条件表达式里可以多重赋值 for i ,j:=0,i go中的多重赋值不能以逗号为间隔，写多个赋值语句，必须使用平行赋值的方法来初始化多个变量 break 标签高级使用 for j:=0;j 使用JLoop:标签可以设定break时的跳出点，具体跳出哪一个for循环 跳转语句 func main(){ i:=0 HERE: i++ if i 同break类似设定一个跳转标签 Copyright© Landers all right reserved，powered by Landers1037更新于 2019-06-01 "},"gonote5.html":{"url":"gonote5.html","title":"函数","keywords":"","body":"Go学习笔记5 函数 函数定义 func Add(a int,b int)(sum int,del int){ return a+b ,a-b } go支持多返回值，当不需要某个返回值的时候，用_占位符表示 函数调用 package myadd func Add(a int,b int)(sum int,del int){ return a+b ,a-b } //调用时 import \"myadd\" myadd.Add(1,2) 注意：go中的函数名大小写意义，首字母大写表示是外部可见 不定参数 func myfunc(args ...int){ for _,arg := range args{ fmt.Println(arg) } } myfunc(1,2,3) 使用语法糖 ...int的形式作为参数，也可以按照一般情况传入参数如下 func myfunc(args []int){ for _,arg := range args{ fmt.Println(arg) } } myfunc([]int{1,2,3}) 可以看到不使用语法糖时，调用函数的写法变得复杂，语法糖是为了方便开发者增加可读性 不定参数的传递 func myfunc(args ...int){ func myfunc2(args...) //按照原样传 func myfunc2(args[1:]...) } 传递任意类型的不定参数 func myfunc(args ...interface{}){ } //eg func main(args ...interface{}){ for _,arg.(type) := range args{ switch arg.(type){ case int: fmt.Print(\"int\") case float32: fmt.Print(\"folat32\") } } } 多返回值 go支持多返回值 匿名函数 使用 func (a int,b int) bool{ return a*b 可以直接赋值给一个变量 f := func (a int,b int) bool{ return a*b 可以直接执行 func (num int){ fmt.Print(num) }(3) //在这里直接传入参数表示调用函数 例子 package main import \"fmt\" func main(){ j := 5 a := func()(func()){ i := 10 return func() { fmt.Println(\"i j is \",i ,j) } }() a() } // i j is 10 5 闭包 匿名函数是一个闭包 对go，闭包的实现确保了只要闭包还在使用，那么闭包引用的变量就会一直存在，闭包也会引用到函数外面的变量 Copyright© Landers all right reserved，powered by Landers1037更新于 2019-06-01 "},"gonote6.html":{"url":"gonote6.html","title":"错误处理","keywords":"","body":"Go学习笔记6 错误处理 go提供error接口，当需要打印错误信息时只需要调用该接口 func (e *Patherror) Error() string{ return e.op + e.path + e.err.Error() } func Stat(name string)(fi FileInfo,err error){ var stat syscall.Stat_t err = syscall.Stat(name,&stat) if err!=nil{ return nil,&Patherror{\"stat\",name,err} } return fileInfoFromStat(&stat,name),nil } //注：Go1.12版本以上部分类型已经更改名称 defer func Copy(dst ,src string)(w int64,err error){ srcFile,err := os.Open(src) if err != nil{ fmt.Println(err) } defer srcFile.Close() dstFile,err := os.Create(dst) if err != nil{ fmt.Println(err) } defer dstFile.Close() return io.Copy(dstFile,srcFile) } func main(){ Copy(\"test.txt\",\"source.txt\") } 加上defer关键字后，就算是后面执行copy()的时候出现了错误，defer后面定义的函数也会正常关闭 defer满足先进后出，所以最后一个defer最先执行 panic()和recover() 用于报告和处理运行时的错误 panic()函数接收任何类型的参数，调用panic()函数的时候，正常函数的执行立即停止，函数会返回到调用函数，最终到达所属的goroutine，其所有正在执行的函数全部停止，打印出错误信息。 recover()函数用于终止错误处理流程 defer func(){ if r := recover();r != nil{ log.Print(\"runntime error caught\",%v,r) } }() foo() 具体需要实践练习 Copyright© Landers all right reserved，powered by Landers1037更新于 2019-06-01 "},"gonote7.html":{"url":"gonote7.html","title":"总结练习","keywords":"","body":"Go学习笔记7-总结练习 一个利用快速排序算法，比较文件中数字的练习 主程序 package main //主程序 import ( \"flag\" \"fmt\" \"bufio\" \"io\" \"os\" \"strconv\" \"goday1-sum/algorithm/qsort\" \"time\" ) var infile *string = flag.String(\"i\",\"unsorted.dat\",\"File contains values for sorting\") var outfile *string = flag.String(\"o\",\"sorted.dat\",\"File to receive sorted values\") var algorithm * string = flag.String(\"a\",\"gsort\",\"sort algorithm\") func readValues(infile string)(values []int,err error){ file,err := os.Open(infile) if err != nil{ fmt.Print(\"Failed to open file\",infile) return } defer file.Close() br := bufio.NewReader(file) values = make([]int ,0) for{ line,isPrefix,err1 := br.ReadLine() if err1 != nil{ if err1 != io.EOF{ err = err1 } } if isPrefix{ fmt.Println(\"a too long line\") return } str := string(line) value,err1 := strconv.Atoi(str) if err1 != nil{ err = err1 return } values = append(values,value) } return } func writeValues(values []int,outfile string)error{ file,err := os.Create(outfile) if err != nil{ fmt.Println(\"Failed to create the output file\",outfile) return err } defer file.Close() for _,value := range values{ str := strconv.Itoa(value) file.WriteString(str + \"\\n\") } return nil } func main() { flag.Parse() if infile != nil{ fmt.Println(\"infile=\",*infile,\"outfile=\",*outfile,\"algorithm=\", *algorithm) } values ,err := readValues(*infile) if err == nil{ fmt.Println(\"Read values:\",values) t1 := time.Now() qsort.QuickSort(values) t2 := time.Now() fmt.Println(\"the sorting process costs\",t2.Sub(t1),\"to complete\") writeValues(values,*outfile) }else{ fmt.Println(\"error\") fmt.Println(err) } } 快速排序算法 package qsort //快速排序 func quickSort(values []int,left,right int) { temp := values[left] p := left i,j := left ,right for i= p && values[j] >= temp{ j-- } if j >= p { values[p] = values[j] p = j } if values[i] 1{ quickSort(values,left,p-1) } if right - p > 1{ quickSort(values,p+1,right) } } func QuickSort(values []int) { quickSort(values,0,len(values)-1) } 文件结构 └── goday1-sum ├── algorithm │ └── qsort │ └── qsort.go ├── goday1-sum.exe └── sorter.go 编译 go build goday1-sum/algorithm go install goday1-sum/algorithm go build goday1-sum go install goday1-sum 最终在bin文件夹下会看到构建成功的可执行文件 测试 在目录下创建unsorted.dat文件放入需要排序的数据 chmod +x goday1-sum ./goday1-sum -i unsorted.dat -o sorted.dat -a qsort 问题 GOPATH的问题一直纠结了很久，很容易出问题 加入在环境变量里如下设置GOPATH，~/Goproject 在~/Goproject下的源文件目录src下新建一个项目文件夹goday1放置主程序main，加入下面有一个test目录，里面是test.go 那么在主程序里引用test包的时候应该这样写，import \"goday1/test\" Copyright© Landers all right reserved，powered by Landers1037更新于 2019-06-01 "},"gonote8.html":{"url":"gonote8.html","title":"对象类型","keywords":"","body":"Go学习笔记8 Go的面向对象 类型的定义 在go中的面向对象与java和c不同，没有严格的继承和接口，只要是实现该类的方法就算是继承了该类 package main //可以发现包含main的文件必须在对应的根目录下 import \"fmt\" //为任意类型添加方法 type Integer int func (a Integer)Less(b Integer) bool{ return a 新建一个类型Integer 继承的是int类型，为其添加新的方法为Less() 面向对象的本质 //使用面向过程的方式解释 func Integer_less(a Integer,b Integer) bool{ return a 就是面向过程的方法，传入对象 想要添加修改对象值的方法，则传入的必须是指针，go里传输数据是靠指针实现的 func main(){ var a Integer =1 a.Add(5) fmt.Println(\"a is \",a) } func (a *Integer)Add(b Integer){ *a += b } 如果传入的不是*Integer指针，最终打印的a值不会改变 值语义和引用语义 go中的类型包括值和引用，大部分都是值语义。 值语义在定义时，值的修改不会影响赋值变量，而引用语义随着值的改变会改变赋值的变量 a := 5 b = a //这是值语义b改变，a不会改变 func main(){ var a = [3]int{1,2,3} //var b = a //值的赋值 //b[1]++ //fmt.Println(a,b) var b = &a //使用的是数组引用 b[1]++ fmt.Println(a,*b) } // [1 3 3] [1 3 3] 对于数组变量，在go中是值类型，但是在赋值的时候如果使用指针赋值而不是变量赋值，就变成了引用语义 var b = &a，如果改变b的值，那么a的值也会对应改变 四类值类型 数组切片 是指向数组元素的指针，但是是值类型 map字典 是一个字典指针，是引用类型 channel通道 是不同的线程通信设施，是引用类型 接口 是引用类型 结构体 在go中结构体和Java的class类是同等级别的，作为面向对象语言，go并没有十分严格遵循面向对象的继承和接口，而是只使用了组合的方式。 定义 type Rect struct { //矩形的长宽 x,y float64 width,height float64 } 定义里面的方法 func (r *Rect) Area() float64{ return r.width * r.height } 构造函数 go没有严格的构造函数用来新建一个对象，而是使用一个全局的创建函数来创建对象 func NewRect(x,y,width,height float64) *Rect{ return &Rect{x,y,width,height} } 匿名组合 go同样提供继承，但是采用组合的方法，成为匿名组合。只要是实现了该对象的方法就算继承了该类 type Base struct { Name string } func (base *Base) Foo(){} //添加新的方法 func (base *Base) Bar(){} type Foo struct { Base //继承Base } func (foo *Foo) Bar(){ foo.Base.Bar() //继承并改写Bar方法 } 有一个Base对象，实现了Foo方法和Bar方法，对象Foo继承了Base，并且对父类Base的Bar方法进行改写。 例子中的foo.Base.Bar()与foo.Bar()效果一致 go还可以使用指针派生 type Foo struct { *Base //继承Base } 派生的用处，当我们调用Foo类的方法时 type Foo struct { *Base.Bar() //继承Base } func (Foo *Foo)Start(){ Foo.Bar(\"hello\") } Foo.Bar()函数传入的参数接收者是*Base.Bar()指针，这个指针不能访问到Foo中的其他参数和成员方法。 接口组合的重复名称问题 type A struct { Name string } type B struct { A Name string } 很明显B是继承自A类，但是B里也有同名的成员Name，但是不会冲突。对B对象的操作，可以访问到的都是B的成员，只能访问最外层的全部成员，A的成员是隐藏的。 可见性 go的大小写对应了不同的访问级别，大写字母开头表示可以被其他包访问 type Rect struct { x,y float64 Width,Height float64 } x,y属性不能被引用Rect的包访问，Width和Height可以被公开访问 成员方法同理 func newRect(x,y,width,height float64) *Rect{ return &Rect{x,y,width,height} } newRect方法不能被其他包调用，只能在该类型所在的包内使用 Copyright© Landers all right reserved，powered by Landers1037更新于 2019-06-02 "},"gonote9.html":{"url":"gonote9.html","title":"接口","keywords":"","body":"Go学习笔记9 接口 接口定义 什么是侵入式接口？ 实现的类必须明确声明自己实现了某个接口 go中的非侵入接口 type File struct { } func (f *File) Read(buf []byte)(n int,err error) func (f *File) Write(buf []byte)(n int,err error) func (f *File) Seek(buf []byte)(n int,err error) 定义了类和方法，假设有如下的接口 type IFile interface{ Read(buf []byte)(n int,err error) Write(buf []byte)(n int,err error) Seek(buf []byte)(n int,err error) } type IReader interface{ Read(buf []byte)(n int,err error) } type IWriter interface{ Write(buf []byte)(n int,err error) } File类并未从这些接口继承，但是却实现了这些接口 var file1 IFile = new(File) var file2 Ireader = new(File) 接口的赋值 type Integer int func (a Integer)Less(b Integer) bool{ return a 定义接口LessAdd type LessAdd interface{ Less(b Integer) bool Add(b Integer) } 将对象赋值给一个接口 var a Integer = 1 var b LessAdd = &a >>1 var b LessAdd = a >>2 使用1就可以让a对象实现LessAdd接口，但是2不行 2传入的a，在方法Add()中，只能改变原值a的值，而不能改变外部操作对象的值，故不能实现该接口 将一个接口赋值给另一个接口 type ReadWrite interface { Read(buf []byte)(n int,err error) Write(buf []byte)(n int,err error) } package two type IStream interface { Read(buf []byte)(n int,err error) Write(buf []byte)(n int,err error) } var file1 two.IStream = new(File) var file2 ReadWrite = new(File) var file3 two.IStream = file2 可以看见接口ReadWrite和IStream都实现了两个方法，所以实现接口1的类也实现了接口2，反之亦然 在赋值的时候也可以直接编译通过 接口的赋值要求接口A必须是接口B的方法列表的子集，此时接口B可以赋值给接口A。否则报错 即接口实现方法多的可以赋值给方法少的接口 接口查询 var file1 Writer = ... if file2 , ok := file1.(two.IStream); ok{ // } if检查file1指向的对象是否实现了two.IStream接口，如果实现了就执行输出语句 接口的查询需要在编译期间进行，而不是在静态类型中检查就可以判断是否可行 特性 go可以查询接口指向的对象是什么类型 var file1 Writer = ... if file2 , ok := file1.(*File); ok{ //询问是否是File类型 } //或者直接询问类型file.(type) 接口组合 type IFile interface{ Read(buf []byte)(n int,err error) Write(buf []byte)(n int,err error) Seek(buf []byte)(n int,err error) } 包含了三种方法，组合了IReader接口和IWriter接口，于是既能实现IReader的功能又能实现IWriter的功能 任意类型 在go中的任意类型都满足空接口interface{}，所以interface{}可以指向任何类型 var v1 interface{} = 1 var v2 interface{} = \"abc\" var v3 interface{} = &v2 //*interface类型赋值给interface 当函数可以接收任意类型的对象实例时，我们将其声明为interface{}类型 Copyright© Landers all right reserved，powered by Landers1037更新于 2019-06-02 "},"gonote10.html":{"url":"gonote10.html","title":"goroutine及通道","keywords":"","body":"Go学习笔记10 并发编程 介绍 并发编程当需要同时处理多个任务的时候，我们用到了并发编程。操作系统级别的概念：多进程，多线程，协程都是属于系统级别的并发模式。 优点 可以同时完成多个任务的处理，提高系统的执行效率 缺点 对系统的开销巨大，耗费系统资源 对比 多进程：最耗费系统cpu资源，创建数量不能过多否则造成系统崩溃，依赖cpu核心数 多线程：占用资源相对多进程较少但是依旧很大，数量不能超过万个 协程：轻量级的线程，可以同时创建几百万个占用的系统资源最少。不直接依赖于系统线程和进程 goroutine 在go中远程支持了并发协程的模式，在这里称为goroutine，它是由go的运行时runtime管理的 使用go关键字调用，每一个go关键字就会开启一个goroutine协程，在被调用的函数返回时，goroutine自动结束 注意：对于go的main函数，main函数在执行完毕后返回程序就会结束运行，退出。不会等待其他的非主goroutine执行完毕。所以以下的写法并不会执行 func main(){ for i :=0;i 一共生成了10个goroutine但是他们调用的add函数并不会执行，因为main函数在他们执行前就返回了 解决：想办法使函数等待所有的goroutine都执行完毕后再退出，这里需要了解go并发的通信方式 goroutine的通信方式 传统的编程语言一般都有两种通信方式：共享数据，交流 并发的难点在于协调，协调在于相互的交流 共享数据：多个并发单元分别保存对同一数据的引用，实现对该数据的共享 消息：多个进程互相通信完成数据通信 在线程间的共享数据时，主要进行线程创建，执行，等待结束，在线程对数据调用的时候数据是死锁安全的，保证了并发不会出错，而因为其中的繁琐的同步和死锁在大量并发的时候会很难分析。go引入了一种数据结构channel通道来完成进程的通信 channel 通道是一种与类型相关的数据结构，所以通道是具有单一类型的，其中传递的数据是单一数据类型的。所以它是一种类型安全的通道 使用通道完成用通信来共享内存 func Count(ch chan int){ ch 定义Count函数用来为一个通道写入一个数据ch ，用循环创建10个goroutine来对相应的channel写入数据，然后使用来读取每一个channel里的数据。 在对每一个channel的数据进行数据的赋值时，在数据被读取前，该操作是阻塞的，不能执行。在对channel的数据进行读取的时候在写入操作完成前，该操作是阻塞的。于是使用channel实现了类似锁的功能，在所有的goroutine完成后，函数才会执行退出。 channel基本语法 一般channel的声明 var channame chan type 例如创建一个map元素是bool型的channel var maochan map[string] chan bool 也可以使用make函数生成一个channel channame := make(chan int) Copyright© Landers all right reserved，powered by Landers1037更新于 2019-06-04 "},"gonote11.html":{"url":"gonote11.html","title":"通道","keywords":"","body":"Go学习笔记11 通道 select使用 select是一种文件句柄的监听机制，使用select函数可以监听系统的文件句柄，一旦一个句柄发生了IO动作，该select函数调用就会被返回。在go中select用于处理异步IO问题 select{ case select语句和switch语句的最大的区别就是select的case里必须是一个文件句柄的IO操作，select后面不需要写判断条件 ch := make(chan int ,1) for{ select{ case ch 随机向通道里写入一个0或者1的过程 缓冲机制 只传输单个的数据的时候，不需要用到缓存，但是当传输的数据量巨大时，我们需要用到缓冲机制来建立通道，从而达到消息队列的效果。 c := make(chan int ,1024) 大小为1024的int型通道 从带有缓冲的通道中读取数据和从不带缓冲的常规通道中读取数据是一样的，但是可以使用range函数来更加简单的实现 for i := range c{ fmt.Println(\"Received:\",i) } 超时机制 并发编程中最需要处理的问题是超时问题，所以需要引入错误处理的机制 go并没有提供超时处理机制的包，但是使用select包可以方便地处理，因为select里的case只要由一个完成就会继续进行下去，而不需要考虑其他case的情况 timeout := make(chan bool,1) go func(){ time.Sleep(1e9) timeout select{ case 无论对ch都读取是否还在等待，从timeout中读取到了数据，程序就会执行下去，从而达到延迟1s的目的 channel的传递 go中的channel作为一个原生的类型，和map同级，所以在channel中传递的也可以是channel type PipeData struct { value int handler func(int) int next chan int } func handle(queue chan *PipeData){ for data := range queue{ data.next 单向channel 如果一个通道是单向的，那么它要么只能写要么只能读。我们使用单向通道来限制函数对通道的操作权限 var ch1 chan int //正常chan var ch2 chan 转换 ch1 := make(chan int) ch2 := 使用 func Read(ch Read函数只拥有ch的读取权限，这样避免了权限的滥用 关闭channel 使用close(ch) 判断是否关闭还可以x,ok := Copyright© Landers all right reserved，powered by Landers1037更新于 2019-06-05 "},"gonote12.html":{"url":"gonote12.html","title":"并行同步","keywords":"","body":"Go学习笔记12 多核并行 在执行运算量大的任务时，将任务分配给多个核运行，达到降低运行时间的目的 type Vector [] float64 func(v Vector) DoSome(i,n int,u Vector,c chan int){ for ;i 在Go原生支持多核并行之前，应该使用环境变量动态分配内核数量 runtime.GOMAXPROCS(16) 出让时间片 我们可以控制goroutine在运行时主动出让时间片来给其他的goroutine，使用runtime包的Goshced()实现 同步 在多个goroutine之间共享数据的时候，就会考虑同步的问题 同步锁 使用sync包的sync.Mutex,sync.RWMutex。Mutex是最简单的锁类型，在一个goroutine获得Mutex后，其他的goroutine必须等待其释放该Mutex。RWMutex是经典的单写多读模型，在该锁的占用情况下，会阻止写但是不阻止读，即多个goroutine可以同时获取读锁RLock(),而写锁Lock()会阻止其他的goroutine读和写。 所有的RLock和Lock都必须有对应的Unlock和RUnlock，否则会导致该锁的所有goroutine处于饥饿状态，造成死锁。 var l sync.Mutex func foo(){ l.Lock() defer l.Unlock() } 全局唯一化操作 对于全局代码，只需要执行一次的代码，使用once类型保证其全局唯一性 var a string var once sync.Once func Setup(){ a = \"hello world\" } func doprint(){ once.Do(setup) print(a) } func twoprint(){ go doprint() go doprint() } 具体的作用：可以发现使用Once后Setup函数只会被调用一次，在Once执行完前其他的函数调用Setup函数时都会被阻塞，保证了该函数只会被执行一次 Copyright© Landers all right reserved，powered by Landers1037更新于 2019-06-05 "}}